# 属性

- 在OC中，对象是数据的基本构造单元，通常通过对象来存储和传递数据。对象会把所需要的数据保存为各种实例变量，加上 setter 和 getter 方法后，就是OC中的“属性”

- 属性 = 实例变量 + 存取方法（setter、getter），等号右边二者由编译器在编译时期执行，在编辑器内看不到源代码；可用`@synthesize`指定实例变量的名字

  ```objective-c
  @interface EOCPerson: NSObject
  @property NSString *firstName;
  @property NSString *lastName;
  @end
  //等价于：
  @interface EOCPerson: NSObject
  - (NSString *)firstName;
  - (void)setFirstName: (NSString *)firstName;
  - (NSString *)lastName;
  - (void)setLastName: (NSString *)lastName;
  - @end
  
  
  //使用@synthesize指定实例变量的名字
  @implementation EOCPerson
  @synthesize firstName =  _myFirstName;
  @synthesize lastName = _myLastName;
  @end
  ```

- 属性点语法调用本质：编译器会把 `.` 转化为对存取方法的调用

  ```objective-c
  EOCPerson *person = [[EOCPerson alloc] init];
  
  person.firstName = @"Bob";
  //等价于：
  [person setFirstName:@"Bob"];
  
  NSString *lastName = person.lastName;
  //等价于：
  NSString *lastName = [person lastName];
  ```

- 在类接口中声明实例变量，意味着对象布局在编译器就已经固定。只要访问该实例，编译器就把它替换成“偏移量”，如果增加新的实例变量会导致偏移量出错，需重新编译。 声明为属性，偏移量会在运行时查找，不需要重新编译

- 使用@dynamic关键字,将不会自动创建实现属性所用的实例变量,也不会为其创建存取方法。访问属性编译器不会警告，他相信这些方法能在运行期找到

  ```objective-c
  @interface EOCPerson : NSObject
  @property NSString *firstName;
  @property NSString *lastName;
  @end
  
  @implementation EOCPerson
  @dynamic firstName, lastName;
  @end
  ```

- ## 属性特质

  ### 原子性

  - atomic：原子的，加同步锁，确保原子性。具备atomic特质的获取方法会通过所定机制来确保其操作的原子性。也就是说，如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值
  - nonatomic：非原子性的，不使用同步锁。使用nonatomic，那么当其中一个线程正在修改某个属性值时，另外一个线程也许会突然闯入，把尚未修改好的属性值读取出来
  - atomic 的原理只是在 setter and getter 方法中加了一个`@synchronized(self)`，并不能保证多线程安全。例如一个线程连续多次读取某个属性的值，而同时还有别的线程在修改这个属性值得时候，也还是一样会读到不同的值。iOS开发中属性都要声明为`nonatomic`，因为在iOS中使用同步锁的开销较大，严重影响了性能，但是在Mac OSX上开发却通常不存在这个性能问题

  ### 读/写权限

  - readwrite（默认值） : 拥有 getter/setter方法（由@synthesize实现的属性会自动生成）
  - readonly : 只拥有getter方法

  ### 内存管理语义

  - assign：“纯量类型” ( CGFloat，NSInteger ) 的简单赋值
  - strong：“拥有关系”，赋新值时，先保留新值，并释放旧值，然后再将新值设置上去
  - weak：“未拥有关系”，赋新值时，既不保留新值，也不释放旧值。在属性所指向的对象遭到摧毁，属性值被清空
  - unsafe_unretained：语义和assign相同，适用于对象类型，非拥有关系。目标对象遭到摧毁，属性值不会被清空
  - copy：不保留新值，而是直接拷贝

  ### 指定存取的方法名

  ```objective-c
  //属性是Boolean型时常用
  @property(nonatomic, readonly, getter=isViewLoaded) BOOL viewLoaded
  ```

# 直接/ 属性访问实例变量

- 直接访问实例变量特点
  - 不经过OC的“方法派送”，速度比较快，因为编译器所生成的代码会直接访问保存对象实例变量的那块内存
  - 跳过setter方法，绕过为属性设置的内存管理
  - 不会触发KVO，要看具体对象行为判断是否产生问题
  - 属性访问相比直接访问：有助于找bug，因为可以在setter和getter方法中加断点
- 在类内读取属性的数据时，应该通过直接实例变量来读，这样不经过Objecit-C的方法派发，编译器编译后的代码结果是直接访问存实例变量的那块内存中的值，而不会生成走方法派发的代码，这样的速度会更快
- 给属性写入数据时，应该通过属性的方式来写入，这样会调用setter方法。但初始化方法以及dealloc方法中，应该直接通过实例变量来读写数据，从而避免子类复写setter方法造成的异常
- 使用了懒加载（惰性初始化）的属性，应该一直保持用属性的方式来读取写入数据

# 对象等同性

- 使用==操作符比较的是两个指针本身，而不是其所指的对象，应该使用NSObject协议中声明的`isEqual:`方法来判断两个对象的等同性

- 如果已知受测的两对象是NSSting类型，使用`isEqualToString:`方法比较；NSArray使用`isEqualToArray:`；NSDictionary使用`isEqualToDictionary:`

- NSObject协议中两个用于判断等同性的关键方法

  ```objective-c
  - (BOOL)isEqual:(id)object;
  - (BSUIntrger)hash;
  ```

  NSObject类对这两个方法的默认实现是：当且仅当其内存地址完全相等时，这两个对象才相等。当`hash`和`isEqual:`返回的值都完全相同的时候才能说这两个对象相等。若两个对象相等，则其哈希码相同；但两个哈希码相同的对象确未必相等，因为存在hash冲突。且编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法

  [Objective-C中的hash方法](https://www.jianshu.com/p/99e171259b92/)

- 通常的等同性判定方法：如果受测的参数与接收该消息的对象都属于同一个类，那么就调用自己编写的判定方法，否则就交由超类来判断

  ```objective-c
  - (BOOL)isEqual:(id)object {
      if ([self class] == [object class]) {
          // 自己编写的等同性判定方法
      } else {
          return [super isEqual:object];
      }
  }
  ```

- 对容器类对象，判断等同性的深度由编写者决定。如NSArray的检测方式为：先看两个数组所含的对象个数是否相同；若相同，则在每个对应位置的两个对象身上调用其`isEqual:`方法。如果对应位置上的对象均相等，那么这两个数组就相等

- 判断容器中可变类的等同性时，需要确保哈希码不是根据对象的“可变部分”计算出来的，或是直接保证放入collection之后就不再改变对象内容

# 类族模式

- 创建类族

  ```objective-c
  typedef NS_ENUM(NSUInteger, EOCEmployeeType) {
      EOCEmployeeTypeDeveloper,
      EOCEmployeeTypeDesigner,
      EOCEmployeeTypeFinance,
  };
  
  @interface EOCEmployee : NSObject
  @property (nonatomic, copy) NSString *name;
  @property (nonatomic, assign) NSUInteger salary;
  
  - (instancetype)init NS_UNAVAILABLE;
  + (instancetype)employeeWithType:(EOCEmployeeType)type;
  
  - (void)doADaysWork;
  
  @end
  
  @implementation EOCEmployee
  
  + (instancetype)employeeWithType:(EOCEmployeeType)type {
      switch (type) {
          case EOCEmployeeTypeDeveloper: {
              return [EOCEmployeeDeveloper new];
          } break;
              
          case EOCEmployeeTypeDesigner: {
              return [EOCEmployeeDesigner new];
          } break;
              
          case EOCEmployeeTypeFinance: {
              return [EOCEmployeeFinance new];
          } break;
      }
  }
  
  @end
  
  ```

  